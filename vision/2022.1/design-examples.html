


<!DOCTYPE HTML>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		<meta content="Vision, Library, Vitis Vision Library, Iterative Pyramidal, Corner Tracking, cornerUpdate, cornersImgToList," name="keywords" />
<meta content="Design examples Using Vitis Vision library." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />

		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
		<link rel="stylesheet" href="https://static.cloud.coveo.com/searchui/v2.4382/css/CoveoFullSearch.css"/>
		<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<meta name="description"/>
		<meta name="keywords"/>
		<meta property="og:title" content=""/>
		<meta property="og:description"/>
		<!-- favicon -->
		<link rel="icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<link rel="shortcut icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<!-- Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css"/>

	<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="37701bd4-e5c0-4ee3-9329-e7475d0b13a7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
		<!-- Google Tag Manager -->
	<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
	<!-- End Google Tag Manager -->
	
        <!-- Google Tag Manager -->
        <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
        <!-- End Google Tag Manager -->	

  
  
  
  

  
      <script type="text/javascript" src="_static/js/jquery.min.js"></script>
	  <script type="text/javascript" src="_static/js/gtm.js"></script>
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
    <script type="text/javascript" src="_static/js/d3dd8c60ed.js"></script>
    <script type="text/javascript" src="_static/js/common-ui-all.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-ui.min.js"></script>
    <script type="text/javascript" src="_static/js/CoveoJsSearch.Lazy.min.js"></script>
    <script type="text/javascript" src="_static/js/linkid.js"></script>
    <script type="text/javascript" src="_static/js/Searchbox.min.js"></script>
    <script type="text/javascript" src="_static/js/header-footer.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/common-ui-all.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/header-footer.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/pro.min.css" media="all" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
	</head>
	<body>
		<div class="xilinx-bs3"/>
		<div class="root responsivegrid">
			<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 aem-Grid--large--16 aem-Grid--xlarge--16 aem-Grid--xxlarge--16 aem-Grid--xxxlarge--16 ">
 <div class="xilinxExperienceFragments experiencefragment aem-GridColumn aem-GridColumn--default--12">

    
    

    



<div class="xf-content-height">
    

<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
    
    <div class="header parbase aem-GridColumn aem-GridColumn--default--12"><noindex>
	<header data-component="header" class="site-header">
		<nav class="navbar navbar-default">
			<div class="container-fluid main-nav">
				<div class="row">
					<div class="navbar-column col-xs-4 col-sm-5">
						<ul class="nav navbar-nav hidden-xs">
							<li>
									<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
								</li>
							<li>
									<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
								</li>
							<li>
									<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
								</li>
							</ul>
							
						<ul class="nav navbar-nav hidden-sm hidden-md hidden-lg">
							<li>
									<button data-target="#header-container-0" data-function="toggle">Solutions</button>
								</li>
							<li>
									<button data-target="#header-container-1" data-function="toggle">Products</button>
								</li>
							<li>
									<button data-target="#header-container-2" data-function="toggle">Company</button>
								</li>
							</ul>
							
						<div id="header-container-0" class="menu-container">
								<div class="navbar-nav-container">
									<ul class="nav navbar-nav">
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
												</li>
										</ul>
									<button data-function="close-menu">
										<span class="fal fa-times" aria-hidden="true"></span>
									</button>
								</div>
							</div>
							<div id="header-container-1" class="menu-container">
								<div class="navbar-nav-container">
									<ul class="nav navbar-nav">
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
												</li>
										</ul>
									<button data-function="close-menu">
										<span class="fal fa-times" aria-hidden="true"></span>
									</button>
								</div>
							</div>
							<div id="header-container-2" class="menu-container">
								<div class="navbar-nav-container">
									<ul class="nav navbar-nav">
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
												</li>
										</ul>
									<button data-function="close-menu">
										<span class="fal fa-times" aria-hidden="true"></span>
									</button>
								</div>
							</div>
							</div>
					<div class="logo-column col-xs-4 col-sm-2">
						<div class="logo">
							<a target="_blank" href="https://www.xilinx.com/">
								<img src="https://github.com/Xilinx/Image-Collateral/blob/main/xilinx-header-logo.svg?raw=true" title="Xilinx Inc"/>
							</a>
						</div>
					</div>

				</div>
			</div>
			</nav></header></noindex></div>
		
	
</div>

    
</div>
</div>

<div class="calloutBanner parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16"><div class="callout-banner">
    Xilinx is now a part of <a target="_blank" href="https://www.amd.com/en/corporate/xilinx-acquisition">AMD</a> |  <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Learn More</a>
</div>
</div>
				<div class="parsys aem-GridColumn--xxxlarge--none aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
						<div class="container-fluid">
							<div class="row">
							<div class="col-xs-12">
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Vitis Vision Library
          

          
          </a>

          
            
            
              <div class="version">
                2022.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

      
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
            
            
            
              
            
            
              <p class="caption"><span class="caption-text">Vitis Vision Library User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#getting-started-with-vitis-vision">Getting Started with Vitis Vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#getting-started-with-hls">Getting Started with HLS</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#design-examples-using-vitis-vision-library">Design Examples Using Vitis Vision Library</a></li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision AIE Library User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html#getting-started-with-vitis-vision-aie">Getting Started with Vitis Vision AIE</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html#design-example-using-vitis-vision-aie-library">Design example Using Vitis Vision AIE Library</a></li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision Library API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#xf-cv-mat-image-container-class">xf::cv::Mat Image Container Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#vitis-vision-library-functions">Vitis Vision Library Functions</a></li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision AIE Library API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-reference-aie.html">xfcvDataMovers</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference-aie.html#vitis-vision-aie-library-functions-api-list-with-performance-estimates">Vitis Vision AIE Library Functions API list with performance estimates</a></li>
</ul>
<p class="caption"><span class="caption-text">Benchmark</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Benchmark.html">Benchmark</a></li>
</ul>
<p class="caption"><span class="caption-text">Release Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="releasenotesxfopencv.html">Release notes</a></li>
</ul>

            
			
			<p class="caption"><span class="caption-text">This Page</span></p>
				<ul class="current">
				  <li class="toctree-l1"><a href="_sources/design-examples.rst.txt"
						rel="nofollow">Show Source</a></li>
				</ul>
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Vitis Vision Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Design Examples Using Vitis Vision Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/design-examples.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="design-examples-using-vitis-vision-library">
<span id="design-example"></span><h1>Design Examples Using Vitis Vision Library<a class="headerlink" href="#design-examples-using-vitis-vision-library" title="Permalink to this headline">¶</a></h1>
<p>All the hardware functions in the library have their own respective
examples that are available in the github. This section provides details
of image processing functions and pipelines implemented using a
combination of various functions in Vitis vision. They illustrate how to
best implement various functionalities using the capabilities of both
the processor and the programmable logic. These examples also illustrate
different ways to implement complex dataflow paths. The following
examples are described in this section:</p>
<ul class="simple">
<li><a class="reference external" href="#interactive-pyramidal">Iterative Pyramidal Dense Optical Flow</a></li>
<li><a class="reference external" href="#corner-tracking">Corner Tracking Using Optical Flow</a></li>
<li><a class="reference external" href="#color-detection">Color Detection</a></li>
<li><a class="reference external" href="#difference-gaussian-filter">Difference of Gaussian Filter</a></li>
<li><a class="reference external" href="#stereo-vision">Stereo Vision Pipeline</a></li>
<li><a class="reference external" href="#x-mlpipeline">Blob From Image</a></li>
<li><a class="reference external" href="#letter-box">Letterbox</a></li>
<li><a class="reference external" href="#isp">Image Sensor Processing pipeline</a></li>
<li><a class="reference external" href="#isp-202">Image Sensor Processing pipeline - 2020.2 version</a></li>
<li><a class="reference external" href="#isp-201">Image Sensor Processing pipeline - 2021.1 version</a></li>
<li><a class="reference external" href="#isp-201hdr">Image Sensor Processing pipeline with HDR</a></li>
<li><a class="reference external" href="#isp-201gtm">Image Sensor Processing pipeline with GTM</a></li>
<li><a class="reference external" href="#isp-201mono">Mono image Sensor Processing pipeline</a></li>
<li><a class="reference external" href="#isp_201rgbir">RGB-IR image Sensor Processing pipeline</a></li>
<li><a class="reference external" href="#_isp-201multistream">Image Sensor Processing multistream pipeline - 2022.1 version</a></li>
</ul>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last"><strong>All the functions in the library are implemented in streaming model except 4. Crop, EdgeTracing, MeanShiftTracking, Rotate are memory mapped implemenations. These functions need to have the flag __SDA_MEM_MAP__ set for compiling correctly</strong></p>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last"><strong>Default depth value for all the memory mapped implemenations(Crop, EdgeTracing, MeanShiftTracking, Rotate) is “_XFCVDEPTH_DEFAULT = -1”.
Default depth value for all the streaming model implemenations is “_XFCVDEPTH_DEFAULT = 2”.</strong></p>
</div>
<div class="section" id="interative-pyramidal">
<span id="id1"></span><h2>Iterative Pyramidal Dense Optical Flow<a class="headerlink" href="#interative-pyramidal" title="Permalink to this headline">¶</a></h2>
<p>The Dense Pyramidal Optical Flow example uses the <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> and
<code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> hardware functions from the Vitis vision
library, to create an image pyramid, iterate over it and compute the
Optical Flow between two input images. The example uses <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> function to compute the image pyramids
of the two input images. The two image pyramids are
processed by <code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code>
function, starting from the smallest image size going up to the largest
image size. The output flow vectors of each iteration are fed back to
the hardware kernel as input to the hardware function. The output of the
last iteration on the largest image size is treated as the output of the
dense pyramidal optical flow example.</p>
<div class="image figure" id="jcr1510602888334-image-jh4-sq2-bcb">
<img alt="" src="_images/bui1554997287170.png" />
</div>
<p>The Iterative Pyramidal Dense Optical Flow is computed in a nested for
loop which runs for iterations*pyramid levels number of iterations. The
main loop starts from the smallest image size and iterates up to the
largest image size. Before the loop iterates in one pyramid level, it
sets the current pyramid level’s height and width, in curr_height and
current_width variables. In the nested loop, the next_height variable is
set to the previous image height if scaling up is necessary, that is, in
the first iterations. As divisions are costly and one time divisions can
be avoided in hardware, the scale factor is computed in the host and
passed as an argument to the hardware kernel. After each pyramid level,
in the first iteration, the scale-up flag is set to let the hardware
function know that the input flow vectors need to be scaled up to the
next higher image size. Scaling up is done using bilinear interpolation
in the hardware kernel.</p>
<p>After all the input data is prepared, and the flags are set, the host
processor calls the hardware function. Please note that the host
function swaps the flow vector inputs and outputs to the hardware
function to iteratively solve the optimization problem.</p>
</div>
<div class="section" id="corner-tracking">
<span id="id2"></span><h2>Corner Tracking Using Optical Flow<a class="headerlink" href="#corner-tracking" title="Permalink to this headline">¶</a></h2>
<p>This example illustrates how to detect and track the characteristic
feature points in a set of successive frames of video. A Harris corner
detector is used as the feature detector, and a modified version of
Lucas Kanade optical flow is used for tracking. The core part of the
algorithm takes in current and next frame as the inputs and outputs the
list of tracked corners. The current image is the first frame in the
set, then corner detection is performed to detect the features to track.
The number of frames in which the points need to be tracked is also
provided as the input.</p>
<p>Corner tracking example uses five hardware functions from the Vitis vision
library <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerHarris</span></code>, <code class="docutils literal notranslate"><span class="pre">xf::cv::</span> <span class="pre">cornersImgToList</span></code>,
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code>, <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code>, and <code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code>.</p>
<div class="image figure" id="ypx1510602888667-image-dmv-5cv-hdb">
<img alt="" src="_images/tpr1554997250097.png" />
</div>
<p>The function, <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code>, has been added to ensure
that the dense flow vectors from the output of
the<code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> function are sparsely picked and stored
in a new memory location as a sparse array. This was done to ensure that
the next function in the pipeline would not have to surf through the
memory by random accesses. The function takes corners from Harris corner
detector and dense optical flow vectors from the dense pyramidal optical
flow function and outputs the updated corner locations, tracking the
input corners using the dense flow vectors, thereby imitating the sparse
optical flow behavior. This hardware function runs at 300 MHz for 10,000
corners on a 720p image, adding very minimal latency to the pipeline.</p>
<div class="section" id="cornerupdate">
<h3>cornerUpdate()<a class="headerlink" href="#cornerupdate" title="Permalink to this headline">¶</a></h3>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">MAXCORNERSNO</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span> <span class="nb">int</span> <span class="n">XFCVDEPTH_IN</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">cornerUpdate</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">list_fix</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="nb">list</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">nCorners</span><span class="p">,</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_IN</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">flow_vectors</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">harris_flag</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id17">
<caption><span class="caption-text">Table: CornerUpdate Function Parameter Descriptions</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Paramete
r</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MAXCORNE
RSNO</td>
<td>Maximum number of corners that the function needs to work
on</td>
</tr>
<tr class="row-odd"><td>TYPE</td>
<td>Input Pixel Type. Only 8-bit, unsigned, 1 channel is
supported (XF_8UC1)</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of input and output image (Must be
multiple of 8)</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of input and output image (Must be multiple
of 8)</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels to be processed per cycle. This function
supports only XF_NPPC1 or 1-pixel per cycle operations.</td>
</tr>
<tr class="row-odd"><td>XFCVDEPTH_IN</td>
<td>Depth of input image</td>
</tr>
<tr class="row-even"><td>list_fix</td>
<td>A list of packed fixed point coordinates of the corner
locations in 16, 5 (16 integer bits and 5 fractional
bits) format. Bits from 20 to 0 represent the column
number, while the bits 41 to 21 represent the row number.
The rest of the bits are used for flag, this flag is set
when the tracked corner is valid.</td>
</tr>
<tr class="row-odd"><td>list</td>
<td>A list of packed positive short integer coordinates of
the corner locations in unsigned short format. Bits from
15 to 0 represent the column number, while the bits 31 to
16 represent the row number. This list is same as the
list output by Harris Corner Detector.</td>
</tr>
<tr class="row-even"><td>nCorners</td>
<td>Number of corners to track</td>
</tr>
<tr class="row-odd"><td>flow_vec
tors</td>
<td>Packed flow vectors as in xf::cv::DensePyrOpticalFlow
function</td>
</tr>
<tr class="row-even"><td>harris_f
lag</td>
<td><p class="first">If set to 1, the function takes input corners from list.</p>
<p class="last">if set to 0, the function takes input corners from
list_fix.</p>
</td>
</tr>
</tbody>
</table>
<p>The example codeworks on an input video which is read and processed
using the Vitis vision library.</p>
</div>
<div class="section" id="cornersimgtolist">
<h3>cornersImgToList()<a class="headerlink" href="#cornersimgtolist" title="Permalink to this headline">¶</a></h3>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">MAXCORNERSNO</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span> <span class="nb">int</span> <span class="n">XFCVDEPTH_IN</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">cornersImgToList</span><span class="p">(</span><span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_IN</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_src</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="nb">list</span><span class="p">[</span><span class="n">MAXCORNERSNO</span><span class="p">],</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="n">ncorners</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the function parameters.</p>
<table border="1" class="docutils" id="id18">
<caption><span class="caption-text">Table: CornerImgToList Function Parameter Descriptions</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Paramete
r</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MAXCORNE
RSNO</td>
<td>Maximum number of corners that the function needs to work
on</td>
</tr>
<tr class="row-odd"><td>TYPE</td>
<td>Input Pixel Type. Only 8-bit, unsigned, 1 channel is
supported (XF_8UC1)</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of input and output image (Must be
multiple of 8)</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of input and output image (Must be multiple
of 8)</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels to be processed per cycle. This function
supports only XF_NPPC1 or 1-pixel per cycle operations.</td>
</tr>
<tr class="row-odd"><td>XFCVDEPTH_IN</td>
<td>Depth of input image</td>
</tr>
<tr class="row-even"><td>_src</td>
<td>The output image of harris corner detector. The size of
this xf::cv::Mat object is the size of the input image to
Harris corner detector. The value of each pixel is 255 if
a corner is present in the location, 0 otherwise.</td>
</tr>
<tr class="row-odd"><td>list</td>
<td>A 32 bit memory allocated, the size of MAXCORNERS, to
store the corners detected by Harris Detector</td>
</tr>
<tr class="row-even"><td>ncorners</td>
<td>Total number of corners detected by Harris, that is, the
number of corners in the list</td>
</tr>
</tbody>
</table>
<div class="section" id="image-processing">
<h4>Image Processing<a class="headerlink" href="#image-processing" title="Permalink to this headline">¶</a></h4>
<p>The following steps demonstrate the Image Processing procedure in the
hardware pipeline</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::cornerharris</span></code> is called to start processing the first input
image</li>
<li>The output of<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerHarris</span></code> is fed to<code class="docutils literal notranslate"><span class="pre">xf::cv::cornersImgToList</span></code>. This function takes in an
image with corners (marked as 255 and 0 elsewhere), and converts them
to a list of corners.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> creates the two image pyramids and
Dense Optical Flow is computed using the two image pyramids as
described in the Iterative Pyramidal Dense Optical Flow example.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> is called with the two image pyramids as
inputs.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> function is called to track the corner locations
in the second image. If harris_flag is enabled, the <code class="docutils literal notranslate"><span class="pre">cornerUpdate</span></code>
tracks corners from the output of the list, else it tracks the
previously tracked corners.</li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">HarrisImg()</span></code> function takes a flag called
harris_flag which is set during the first frame or when the corners need
to be redetected. The <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> function outputs the updated
corners to the same memory location as the output corners list of
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerImgToList</span></code>. This means that when harris_flag is unset, the
corners input to the <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> are the corners tracked in the
previous cycle, that is, the corners in the first frame of the current
input frames.</p>
<p>After the Dense Optical Flow is computed, if harris_flag is set, the
number of corners that <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerharris</span></code> has detected and
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornersImgToList</span></code> has updated is copied to num_corners variable
. The other being the tracked corners list, listfixed. If
harris_flag is set, <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> tracks the corners in ‘list’
memory location, otherwise it tracks the corners in ‘listfixed’ memory
location.</p>
</div>
</div>
</div>
<div class="section" id="id3">
<span id="id4"></span><h2>Color Detection<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>The Color Detection algorithm is basically used for color object
tracking and object detection, based on the color of the object. The
color based methods are very useful for object detection and
segmentation, when the object and the background have a significant
difference in color.</p>
<p>The Color Detection example uses four hardware functions from the
Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::BGR2HSV</li>
<li>xf::cv::colorthresholding</li>
<li>xf::cv::erode</li>
<li>xf::cv::dilate</li>
</ul>
<p>In the Color Detection example, the color space of the original BGR
image is converted into an HSV color space. Because HSV color space is
the most suitable color space for color based image segmentation. Later,
based on the H (hue), S (saturation) and V (value) values, apply the
thresholding operation on the HSV image and return either 255 or 0.
After thresholding the image, apply erode (morphological opening) and
dilate (morphological opening) functions to reduce unnecessary white
patches (noise) in the image. Here, the example uses two hardware
instances of erode and dilate functions. The erode followed by dilate
and once again applying dilate followed by erode.</p>
<div class="image figure" id="dyn1510602889272-image-dzq-ys2-bcb">
<img alt="" src="_images/ntl1554997353703.png" />
</div>
<p>The following example demonstrates the Color Detection algorithm.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">color_detect</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_IN_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_in</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">low_thresh</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">high_thresh</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">process_shape</span><span class="p">,</span>
              <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_OUT_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
              <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span>
              <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi      port=img_in        offset=slave  bundle=gmem0</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=low_thresh    offset=slave  bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=low_thresh</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=high_thresh   offset=slave  bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=high_thresh</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=rows</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=cols</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=process_shape offset=slave  bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=process_shape</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=img_out       offset=slave  bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=return</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="o">&gt;</span> <span class="n">imgInput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rgb2hsv</span><span class="o">&gt;</span> <span class="n">rgb2hsv</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper1</span><span class="o">&gt;</span> <span class="n">imgHelper1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper2</span><span class="o">&gt;</span> <span class="n">imgHelper2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper3</span><span class="o">&gt;</span> <span class="n">imgHelper3</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper4</span><span class="o">&gt;</span> <span class="n">imgHelper4</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgOutput</span><span class="o">&gt;</span> <span class="n">imgOutput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">shape</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">unsigned</span> <span class="n">char</span> <span class="n">_kernel</span><span class="p">[</span><span class="n">FILTER_SIZE</span> <span class="o">*</span> <span class="n">FILTER_SIZE</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FILTER_SIZE</span> <span class="o">*</span> <span class="n">FILTER_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS PIPELINE</span>
                    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
                    <span class="n">_kernel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_shape</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>

    <span class="c1">#pragma HLS DATAFLOW</span>
            <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
            <span class="o">//</span> <span class="n">Retrieve</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="n">objects</span> <span class="kn">from</span> <span class="nn">img_in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">PTR_IN_WIDTH</span><span class="p">,</span> <span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_in</span><span class="p">,</span> <span class="n">imgInput</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Convert</span> <span class="n">RGBA</span> <span class="n">to</span> <span class="n">HSV</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">bgr2hsv</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rgb2hsv</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput</span><span class="p">,</span> <span class="n">rgb2hsv</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Do</span> <span class="n">the</span> <span class="n">color</span> <span class="n">thresholding</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">colorthresholding</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">MAXCOLORS</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rgb2hsv</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rgb2hsv</span><span class="p">,</span> <span class="n">imgHelper1</span><span class="p">,</span> <span class="n">low_thresh</span><span class="p">,</span>
                                                                                                                                                                     <span class="n">high_thresh</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Use</span> <span class="n">erode</span> <span class="ow">and</span> <span class="n">dilate</span> <span class="n">to</span> <span class="n">fully</span> <span class="n">mark</span> <span class="n">color</span> <span class="n">areas</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">erode</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                      <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper1</span><span class="p">,</span> <span class="n">imgHelper2</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">dilate</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                       <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper2</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper2</span><span class="p">,</span> <span class="n">imgHelper3</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">dilate</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                       <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper3</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper3</span><span class="p">,</span> <span class="n">imgHelper4</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">erode</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                      <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper4</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgOutput</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper4</span><span class="p">,</span> <span class="n">imgOutput</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Convert</span> <span class="n">_dst</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="nb">object</span> <span class="n">to</span> <span class="n">output</span> <span class="n">array</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">PTR_OUT_WIDTH</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgOutput</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>

            <span class="k">return</span><span class="p">;</span>

    <span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>In the given example, the source image is passed to the <code class="docutils literal notranslate"><span class="pre">xf::cv::BGR2HSV</span></code>
function, the output of that function is passed to the
<code class="docutils literal notranslate"><span class="pre">xf::cv::colorthresholding</span></code> module, the thresholded image is passed to the
<code class="docutils literal notranslate"><span class="pre">xf::cv::erode</span></code> function and, the <code class="docutils literal notranslate"><span class="pre">xf::cv::dilate</span></code> functions and the final
output image are returned.</p>
</div>
<div class="section" id="difference-gaussian-filter">
<span id="id5"></span><h2>Difference of Gaussian Filter<a class="headerlink" href="#difference-gaussian-filter" title="Permalink to this headline">¶</a></h2>
<p>The Difference of Gaussian Filter example uses four hardware functions
from the Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::GaussianBlur</li>
<li>xf::cv::duplicateMat</li>
<li>xf::cv::subtract</li>
</ul>
<p>The Difference of Gaussian Filter function can be implemented by
applying Gaussian Filter on the original source image, and that Gaussian
blurred image is duplicated as two images. The Gaussian blur function is
applied to one of the duplicated images, whereas the other one is stored
as it is. Later, perform the Subtraction function on, two times Gaussian
applied image and one of the duplicated image.</p>
<div class="image figure" id="fmq1510602889620-image-lgr-1xf-bcb">
<img alt="" src="_images/crx1554997276344.png" />
</div>
<p>The following example demonstrates the Difference of Gaussian Filter
example.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">gaussiandiference</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_in</span><span class="p">,</span> <span class="nb">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi      port=img_in        offset=slave  bundle=gmem0</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=img_out       offset=slave  bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=sigma</span>
    <span class="c1">#pragma HLS INTERFACE s_axilite  port=rows</span>
    <span class="c1">#pragma HLS INTERFACE s_axilite  port=cols</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=return</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgInput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span> <span class="n">imgin3</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin4</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgOutput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

    <span class="c1">#pragma HLS DATAFLOW</span>

            <span class="o">//</span> <span class="n">Retrieve</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="n">objects</span> <span class="kn">from</span> <span class="nn">img_in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_in</span><span class="p">,</span> <span class="n">imgInput</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Run</span> <span class="n">xfOpenCV</span> <span class="n">kernel</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">GaussianBlur</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span> <span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput</span><span class="p">,</span> <span class="n">imgin1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">duplicateMat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin1</span><span class="p">,</span> <span class="n">imgin2</span><span class="p">,</span> <span class="n">imgin3</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">GaussianBlur</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span> <span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin2</span><span class="p">,</span> <span class="n">imgin4</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">subtract</span><span class="o">&lt;</span><span class="n">XF_CONVERT_POLICY_SATURATE</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin3</span><span class="p">,</span> <span class="n">imgin4</span><span class="p">,</span> <span class="n">imgOutput</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Convert</span> <span class="n">output</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="nb">object</span> <span class="n">to</span> <span class="n">output</span> <span class="n">array</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>

            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>In the given example, the Gaussain Blur function is applied for source
image imginput, and resultant image imgin1 is passed to
xf::cv::duplicateMat. The imgin2 and imgin3 are the duplicate images of
Gaussian applied image. Again gaussian blur is applied to imgin2 and the
result is stored in imgin4. Now, perform the subtraction between imgin4
and imgin3, but here imgin3 has to wait up to at least one pixel of
imgin4 generation. Finally the subtraction performed on imgin3 and imgin4.</p>
</div>
<div class="section" id="stereo-vision">
<span id="id6"></span><h2>Stereo Vision Pipeline<a class="headerlink" href="#stereo-vision" title="Permalink to this headline">¶</a></h2>
<p>Disparity map generation is one of the first steps in creating a three
dimensional map of the environment. The Vitis vision library has components
to build an image processing pipeline to compute a disparity map given
the camera parameters and inputs from a stereo camera setup.</p>
<p>The two main components involved in the pipeline are stereo
rectification and disparity estimation using local block matching
method. While disparity estimation using local block matching is a
discrete component in Vitis vision, rectification block can be constructed
using <code class="docutils literal notranslate"><span class="pre">xf::cv::InitUndistortRectifyMapInverse()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::Remap()</span></code>. The
dataflow pipeline is shown below. The camera parameters are an
additional input to the pipeline.</p>
<div class="image figure">
<a class="reference internal image-reference" href="_images/qlb1554997048260.png"><img alt="" src="_images/qlb1554997048260.png" style="width: 560px; height: 240px;" /></a>
</div>
<p>The following code is for the pipeline.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">stereopipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_L</span><span class="p">,</span>
                      <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_R</span><span class="p">,</span>
                      <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_disp</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">cameraMA_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">cameraMA_r</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">distC_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">distC_r</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">irA_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">irA_r</span><span class="p">,</span>
                      <span class="nb">int</span><span class="o">*</span> <span class="n">bm_state_arr</span><span class="p">,</span>
                      <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span>
                      <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi     port=img_L  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_R  offset=slave bundle=gmem5</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_disp  offset=slave bundle=gmem6</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=cameraMA_l  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=cameraMA_r  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=distC_l  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=distC_r  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=irA_l  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=irA_r  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=bm_state_arr  offset=slave bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=rows</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=return</span>

            <span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span> <span class="n">cameraMA_l_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span> <span class="n">cameraMA_r_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span>
                    <span class="n">distC_l_fix</span><span class="p">[</span><span class="n">XF_DIST_COEFF_SIZE</span><span class="p">],</span> <span class="n">distC_r_fix</span><span class="p">[</span><span class="n">XF_DIST_COEFF_SIZE</span><span class="p">],</span> <span class="n">irA_l_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span>
                    <span class="n">irA_r_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">];</span>

            <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS PIPELINE II=1</span>
                    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
                    <span class="n">cameraMA_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">cameraMA_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">cameraMA_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">cameraMA_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">irA_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">irA_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">irA_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">irA_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS PIPELINE II=1</span>
                    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
                    <span class="n">distC_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">distC_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">distC_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">distC_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xFSBMState</span><span class="o">&lt;</span><span class="n">SAD_WINDOW_SIZE</span><span class="p">,</span> <span class="n">NO_OF_DISPARITIES</span><span class="p">,</span> <span class="n">PARALLEL_UNITS</span><span class="o">&gt;</span> <span class="n">bm_state</span><span class="p">;</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterType</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterSize</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterCap</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">SADWindowSize</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">minDisparity</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">numberOfDisparities</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">textureThreshold</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">uniquenessRatio</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">ndisp_unit</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">sweepFactor</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">remainder</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

            <span class="nb">int</span> <span class="n">_cm_size</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">_dc_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_L</span><span class="o">&gt;</span> <span class="n">mat_L</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_R</span><span class="o">&gt;</span> <span class="n">mat_R</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_DISP</span><span class="o">&gt;</span> <span class="n">mat_disp</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XL</span><span class="o">&gt;</span> <span class="n">mapxLMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YL</span><span class="o">&gt;</span> <span class="n">mapyLMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XR</span><span class="o">&gt;</span> <span class="n">mapxRMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YR</span><span class="o">&gt;</span> <span class="n">mapyRMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_LEFT_REMAPPED</span><span class="o">&gt;</span> <span class="n">leftRemappedMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_RIGHT_REMAPPED</span><span class="o">&gt;</span> <span class="n">rightRemappedMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>


    <span class="c1">#pragma HLS DATAFLOW</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_L</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_L</span><span class="p">,</span> <span class="n">mat_L</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_R</span><span class="p">,</span> <span class="n">mat_R</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">InitUndistortRectifyMapInverse</span><span class="o">&lt;</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">,</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                                                                       <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XL</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YL</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cameraMA_l_fix</span><span class="p">,</span> <span class="n">distC_l_fix</span><span class="p">,</span> <span class="n">irA_l_fix</span><span class="p">,</span> <span class="n">mapxLMat</span><span class="p">,</span> <span class="n">mapyLMat</span><span class="p">,</span>
                                                                                                             <span class="n">_cm_size</span><span class="p">,</span> <span class="n">_dc_size</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">remap</span><span class="o">&lt;</span><span class="n">XF_REMAP_BUFSIZE</span><span class="p">,</span> <span class="n">XF_INTERPOLATION_BILINEAR</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                      <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_L</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_LEFT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XL</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YL</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_L</span><span class="p">,</span> <span class="n">leftRemappedMat</span><span class="p">,</span> <span class="n">mapxLMat</span><span class="p">,</span> <span class="n">mapyLMat</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">InitUndistortRectifyMapInverse</span><span class="o">&lt;</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">,</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                                                                       <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XR</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YR</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cameraMA_r_fix</span><span class="p">,</span> <span class="n">distC_r_fix</span><span class="p">,</span> <span class="n">irA_r_fix</span><span class="p">,</span> <span class="n">mapxRMat</span><span class="p">,</span> <span class="n">mapyRMat</span><span class="p">,</span>
                                                                                                             <span class="n">_cm_size</span><span class="p">,</span> <span class="n">_dc_size</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">remap</span><span class="o">&lt;</span><span class="n">XF_REMAP_BUFSIZE</span><span class="p">,</span> <span class="n">XF_INTERPOLATION_BILINEAR</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                      <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_R</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_RIGHT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XR</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YR</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_R</span><span class="p">,</span> <span class="n">rightRemappedMat</span><span class="p">,</span> <span class="n">mapxRMat</span><span class="p">,</span> <span class="n">mapyRMat</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">StereoBM</span><span class="o">&lt;</span><span class="n">SAD_WINDOW_SIZE</span><span class="p">,</span> <span class="n">NO_OF_DISPARITIES</span><span class="p">,</span> <span class="n">PARALLEL_UNITS</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                             <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_LEFT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_RIGHT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_DISP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">leftRemappedMat</span><span class="p">,</span> <span class="n">rightRemappedMat</span><span class="p">,</span> <span class="n">mat_disp</span><span class="p">,</span> <span class="n">bm_state</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_DISP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_disp</span><span class="p">,</span> <span class="n">img_disp</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="x-mlpipeline">
<span id="id7"></span><h2>Blob From Image<a class="headerlink" href="#x-mlpipeline" title="Permalink to this headline">¶</a></h2>
<p>This example shows how various xfOpenCV funtions can be used to accelerate preprocessing of input images before feeding them to a Deep Neural Network (DNN) accelerator.</p>
<p>This specific application shows how pre-processing for Googlenet_v1 can be accelerated which involves resizing the input image to 224 x 224 size followed by mean subtraction. The two main
functions from Vitis vision library which are used to build this pipeline are <code class="docutils literal notranslate"><span class="pre">xf::cv::resize()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::preProcess()</span></code> which operate in dataflow.</p>
<p><a class="image reference internal" href="_images/gnet_pp.png"><img alt="pp_image" class="image" src="_images/gnet_pp.png" style="width: 500px;" /></a></p>
<p>The following code shows the top level wrapper containing the <code class="docutils literal notranslate"><span class="pre">xf::cv::resize()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::preProcess()</span></code> calls.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">pp_pipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows_in</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols_in</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols_out</span><span class="p">,</span> <span class="nb">float</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">T_CHANNELS</span><span class="p">],</span> <span class="nb">int</span> <span class="n">th1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">th2</span><span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span><span class="n">HLS</span> <span class="n">Interface</span> <span class="n">pragmas</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=params  offset=slave bundle=gmem3</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=rows_in     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols_in     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=rows_out     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols_out     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=th1     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=th2     bundle=control</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=return   bundle=control</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC3</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span>   <span class="n">imgInput0</span><span class="p">(</span><span class="n">rows_in</span><span class="p">,</span> <span class="n">cols_in</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span> <span class="n">out_mat</span><span class="p">(</span><span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">);</span>

    <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">256</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">resizeStrmout</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">srcMat_cols_align_npc</span> <span class="o">=</span> <span class="p">((</span><span class="n">out_mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="p">(</span><span class="n">NPC_T</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">NPC_T</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">NPC_T</span><span class="p">);</span>

    <span class="c1">#pragma HLS DATAFLOW</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC3</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span>  <span class="p">(</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">imgInput0</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">resize</span><span class="o">&lt;</span><span class="n">INTERPOLATION</span><span class="p">,</span><span class="n">TYPE</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">NEWHEIGHT</span><span class="p">,</span><span class="n">NEWWIDTH</span><span class="p">,</span><span class="n">NPC_T</span><span class="p">,</span><span class="n">MAXDOWNSCALE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">imgInput0</span><span class="p">,</span> <span class="n">out_mat</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">accel_utils</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">xfMat2hlsStrm</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="p">(</span><span class="n">NEWWIDTH</span><span class="o">*</span><span class="n">NEWHEIGHT</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat</span><span class="p">,</span> <span class="n">resizeStrmout</span><span class="p">,</span> <span class="n">srcMat_cols_align_npc</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">preProcess</span> <span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">T_CHANNELS</span><span class="p">,</span> <span class="n">CPW</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_TEST</span><span class="p">,</span> <span class="n">PACK_MODE</span><span class="p">,</span> <span class="n">X_WIDTH</span><span class="p">,</span> <span class="n">ALPHA_WIDTH</span><span class="p">,</span> <span class="n">BETA_WIDTH</span><span class="p">,</span> <span class="n">GAMMA_WIDTH</span><span class="p">,</span> <span class="n">OUT_WIDTH</span><span class="p">,</span> <span class="n">X_IBITS</span><span class="p">,</span> <span class="n">ALPHA_IBITS</span><span class="p">,</span> <span class="n">BETA_IBITS</span><span class="p">,</span> <span class="n">GAMMA_IBITS</span><span class="p">,</span> <span class="n">OUT_IBITS</span><span class="p">,</span> <span class="n">SIGNED_IN</span><span class="p">,</span> <span class="n">OPMODE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">resizeStrmout</span><span class="p">,</span> <span class="n">img_out</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>This piepeline is integrated with Deep learning Processign Unit(DPU) as part of <a class="reference external" href="https://github.com/Xilinx/Vitis-AI">Vitis-AI-Library</a>  and achieved
11 % speed up compared to software pre-procesing.</p>
<ul class="simple">
<li>Overall Performance (Images/sec):</li>
<li>with software pre-processing : 125 images/sec</li>
<li>with hardware accelerated pre-processing : 140 images/sec</li>
</ul>
</div>
<div class="section" id="letter-box">
<span id="id8"></span><h2>Letterbox<a class="headerlink" href="#letter-box" title="Permalink to this headline">¶</a></h2>
<p>The Letterbox algorithm is used for scaling input image to desired output size while preserving aspect ratio of original image. If required, zeroes are padded for preserving the aspect ratio post resize.</p>
<p>An application of letterbox is in the pre-processing block of machine learning pipelines used in image processing.</p>
<p><a class="image reference internal" href="_images/letterbox.PNG"><img alt="pp_image1" class="image" src="_images/letterbox.PNG" style="width: 1000px;" /></a></p>
<p>The following example demonstrates the Letterbox algorithm.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">letterbox_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp</span><span class="p">,</span>
                    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">rows_in</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">cols_in</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">rows_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">cols_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">insert_pad_value</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
            <span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=rows_in</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=cols_in</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=rows_out</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=cols_out</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=insert_pad_value</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=return</span>


                    <span class="o">//</span> <span class="n">Compute</span> <span class="n">Resize</span> <span class="n">output</span> <span class="n">image</span> <span class="n">size</span> <span class="k">for</span> <span class="n">Letterbox</span>
                    <span class="nb">float</span> <span class="n">scale_height</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_out</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_in</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">scale_width</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_out</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_in</span><span class="p">;</span>
                    <span class="nb">int</span> <span class="n">rows_out_resize</span><span class="p">,</span> <span class="n">cols_out_resize</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">scale_width</span><span class="o">&lt;</span><span class="n">scale_height</span><span class="p">){</span>
                            <span class="n">cols_out_resize</span> <span class="o">=</span> <span class="n">cols_out</span><span class="p">;</span>
                            <span class="n">rows_out_resize</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)((</span><span class="nb">float</span><span class="p">)(</span><span class="n">rows_in</span><span class="o">*</span><span class="n">cols_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_in</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span><span class="p">{</span>
                            <span class="n">cols_out_resize</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)((</span><span class="nb">float</span><span class="p">)(</span><span class="n">cols_in</span><span class="o">*</span><span class="n">rows_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_in</span><span class="p">);</span>
                            <span class="n">rows_out_resize</span> <span class="o">=</span> <span class="n">rows_out</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="o">&gt;</span> <span class="n">imgInput0</span><span class="p">(</span><span class="n">rows_in</span><span class="p">,</span> <span class="n">cols_in</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_1</span><span class="o">&gt;</span> <span class="n">out_mat_resize</span><span class="p">(</span><span class="n">rows_out_resize</span><span class="p">,</span> <span class="n">cols_out_resize</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span> <span class="n">out_mat</span><span class="p">(</span><span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">);</span>

            <span class="c1">#pragma HLS DATAFLOW</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC3</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="o">&gt;</span>  <span class="p">(</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">imgInput0</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">resize</span><span class="o">&lt;</span><span class="n">INTERPOLATION</span><span class="p">,</span><span class="n">TYPE</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">NEWHEIGHT</span><span class="p">,</span><span class="n">NEWWIDTH</span><span class="p">,</span><span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_1</span><span class="p">,</span><span class="n">MAXDOWNSCALE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">imgInput0</span><span class="p">,</span> <span class="n">out_mat_resize</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">insertBorder</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat_resize</span><span class="p">,</span> <span class="n">out_mat</span><span class="p">,</span> <span class="n">insert_pad_value</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span><span class="o">//</span> <span class="n">end</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>The Letterbox example uses two hardware functions from the Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::resize</li>
<li>xf::cv::insertBorder</li>
</ul>
<p>In the given example, the source image is passed to the xf::cv::resize function.
The output of that function is passed to the xf::cv::insertBorder module and the final output image are returned.</p>
<p class="rubric">Insert Border API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span>
    <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">SRC_ROWS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">SRC_COLS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">DST_ROWS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">DST_COLS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span>
        <span class="nb">int</span> <span class="n">XFCVDEPTH_IN</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span><span class="p">,</span>
<span class="nb">int</span> <span class="n">XFCVDEPTH_OUT</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span>
    <span class="o">&gt;</span>
<span class="n">void</span> <span class="n">insertBorder</span> <span class="p">(</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">SRC_ROWS</span><span class="p">,</span> <span class="n">SRC_COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_IN</span><span class="o">&gt;&amp;</span> <span class="n">_src</span><span class="p">,</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">DST_ROWS</span><span class="p">,</span> <span class="n">DST_COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_OUT</span><span class="o">&gt;&amp;</span> <span class="n">_dst</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">insert_pad_val</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="isp">
<span id="id9"></span><h2>Image Sensor Processing pipeline<a class="headerlink" href="#isp" title="Permalink to this headline">¶</a></h2>
<p>Image Sensor Processing (ISP) is a pipeline of image processing functions processing the raw image from the sensor.</p>
<p>Current ISP includes following 4 blocks:</p>
<ul class="simple">
<li>BPC (Bad pixel correction) : An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control : The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing : The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
</ul>
<p>Current design example demonstrates how to use ISP functions in a pipeline. User can include other modules (like gamma correction, color conversion, resize etc) based on their need.</p>
<p><a class="image reference internal" href="_images/isp.png"><img alt="pp_image_es" class="image" src="_images/isp.png" style="width: 1000px;" /></a></p>
<p>The following example demonstrates the ISP pipeline.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp, ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out, int height, int width) {

#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2
#pragma HLS INTERFACE s_axilite port=height
#pragma HLS INTERFACE s_axilite port=width
#pragma HLS INTERFACE s_axilite port=return
#pragma HLS ARRAY_PARTITION variable=hist0 complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1 complete dim=1

        if (!flag) {
                ISPpipeline(img_inp, img_out, height, width, hist0, hist1);
                flag = 1;
        } else {
                ISPpipeline(img_inp, img_out, height, width, hist1, hist0);
                flag = 0;
        }
}
void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                 ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                 int height,
                                 int width,
                                 uint32_t hist0[3][256],
                                 uint32_t hist1[3][256]) {
#pragma HLS INLINE OFF
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; imgInput1(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; bpc_out(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; gain_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; demosaic_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; impop(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; _dst(height, width);

#pragma HLS stream variable=bpc_out.data dim=1 depth=2
#pragma HLS stream variable=gain_out.data dim=1 depth=2
#pragma HLS stream variable=demosaic_out.data dim=1 depth=2
#pragma HLS stream variable=imgInput1.data dim=1 depth=2
#pragma HLS stream variable=impop.data dim=1 depth=2
#pragma HLS stream variable=_dst.data dim=1 depth=2

#pragma HLS DATAFLOW


        float inputMin = 0.0f;
        float inputMax = 255.0f;
        float outputMin = 0.0f;
        float outputMax = 255.0f;
        float p = 2.0f;

        xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(img_inp, imgInput1);
        xf::cv::badpixelcorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, 0&gt;(imgInput1, bpc_out);
        xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(bpc_out, gain_out);
        xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0&gt;(gain_out, demosaic_out);
        xf::cv::AWBhistogram&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, WB_TYPE&gt;(
                demosaic_out, impop, hist0, p, inputMin, inputMax, outputMin, outputMax);
        xf::cv::AWBNormalization&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, WB_TYPE&gt;(impop, _dst, hist1, p, inputMin,
                                                                                                                                                                                inputMax, outputMin, outputMax);
        xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(_dst, img_out);
}
</pre></div>
</div>
</div>
<div class="section" id="isp-202">
<span id="id10"></span><h2>Image Sensor Processing pipeline - 2020.2 version<a class="headerlink" href="#isp-202" title="Permalink to this headline">¶</a></h2>
<p>This ISP includes following 8 blocks:</p>
<ul class="simple">
<li>Black level correction : Black level leads to the whitening of image in dark region and perceived loss of overall
contrast. The Blacklevelcorrection algorithm corrects the black and white levels of the overall image.</li>
<li>BPC (Bad pixel correction) : An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control : The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing : The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
<li>Colorcorrection matrix : corrects color suitable for display or video system.</li>
<li>Quantization and Dithering : Quantization and Dithering performs the uniform quantization to also reduce higher bit depth to lower bit depths.</li>
<li>Autoexposurecorrection : This function automatically attempts to correct the exposure level of captured image and also improves contrast of the image.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-2020_2.PNG"><img alt="isp_20202" class="image" src="_images/isp-2020_2.PNG" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline. User can include other modules (like gamma correction, color conversion, resize etc) based on their need.</p>
<p>The following example demonstrates the ISP pipeline with above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp, ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out, int height, int width) {

#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2

#pragma HLS ARRAY_PARTITION variable=hist0 complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1 complete dim=1

        if (!flag) {
                ISPpipeline(img_inp, img_out, height, width, hist0, hist1, histogram0, histogram1, igain_0, igain_1);
                flag = 1;

        } else {
                ISPpipeline(img_inp, img_out, height, width, hist1, hist0, histogram1, histogram0, igain_1, igain_0);
                flag = 0;
        }
}

void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                unsigned short height,
                                unsigned short width,
                                uint32_t hist0[3][HIST_SIZE],
                                uint32_t hist1[3][HIST_SIZE],
                                uint32_t hist_aec1[1][256],
                                uint32_t hist_aec2[1][256],
                                int gain0[3], int gain1[3]) {

        #pragma HLS INLINE OFF

                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; imgInput1(height, width);
                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; imgInput2(height, width);
                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; bpc_out(height, width);
                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; gain_out(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; demosaic_out(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; impop(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; ltm_in(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; lsc_out(height, width);
                xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; _dst(height, width);
                xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt; aecin(height, width);

        #pragma HLS stream variable=bpc_out.data dim=1 depth=2
        #pragma HLS stream variable=gain_out.data dim=1 depth=2
        #pragma HLS stream variable=demosaic_out.data dim=1 depth=2
        #pragma HLS stream variable=imgInput1.data dim=1 depth=2
        #pragma HLS stream variable=imgInput2.data dim=1 depth=2
        #pragma HLS stream variable=impop.data dim=1 depth=2
        #pragma HLS stream variable=_dst.data dim=1 depth=2
        #pragma HLS stream variable=ltm_in.data dim=1 depth=2
        #pragma HLS stream variable=lsc_out.data dim=1 depth=2
        #pragma HLS stream variable=aecin.data dim=1 depth=2

        #pragma HLS DATAFLOW

                float inputMin = 0.0f;
                float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
                float outputMin = 0.0f;
                float outputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
                float p = 0.2f;
                float thresh = 0.6f;

                float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));

                xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(img_inp, imgInput1);
                xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1&gt;(imgInput1, imgInput2, BLACK_LEVEL,
                                                                                                                                                                                mul_fact);

                xf::cv::badpixelcorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, 0&gt;(imgInput2, bpc_out);
                xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(bpc_out, gain_out);
                xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0&gt;(gain_out, demosaic_out);

                if (WB_TYPE) {
                        xf::cv::AWBhistogram&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, WB_TYPE, HIST_SIZE&gt;(
                                demosaic_out, impop, hist0, thresh, inputMin, inputMax, outputMin, outputMax);
                        xf::cv::AWBNormalization&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, WB_TYPE, HIST_SIZE&gt;(
                                impop, ltm_in, hist1, thresh, inputMin, inputMax, outputMin, outputMax);
                } else {
                        xf::cv::AWBChannelGain&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0&gt;(demosaic_out, impop, p, gain0);
                        xf::cv::AWBGainUpdate&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0&gt;(impop, ltm_in, p, gain1);
                }

                xf::cv::colorcorrectionmatrix&lt;XF_CCM_TYPE, XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(ltm_in, lsc_out);

                xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, 65536, XF_NPPC&gt;(lsc_out, aecin);

                if (AEC_EN) {
                        xf::cv::autoexposurecorrection&lt;XF_LTM_T, XF_LTM_T, SIN_CHANNEL_TYPE, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(
                                aecin, _dst, hist_aec1, hist_aec2);

                        xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(_dst, img_out);
                }

                xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC&gt;(aecin, img_out);
        }
</pre></div>
</div>
</div>
<div class="section" id="isp-201">
<span id="id11"></span><h2>Image Sensor Processing pipeline - 2021.1 version<a class="headerlink" href="#isp-201" title="Permalink to this headline">¶</a></h2>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>Black level correction : Black level leads to the whitening of image in dark region and perceived loss of overall
contrast. The Blacklevelcorrection algorithm corrects the black and white levels of the overall image.</li>
<li>BPC (Bad pixel correction) : An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control : The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing : The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
<li>Colorcorrection matrix : corrects color suitable for display or video system.</li>
<li>Quantization and Dithering : Quantization and Dithering performs the uniform quantization to also reduce higher bit depth to lower bit depths.</li>
<li>Gamma correction : Gamma correction improves the overall brightness of image.</li>
<li>Color space conversion : Converting RGB image to YUV422(YUYV) image for HDMI display purpose.RGB2YUYV converts the RGB image into Y channel for every pixel and U and V for alternate pixels.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-2021_1.PNG"><img alt="isp-20211" class="image" src="_images/isp-2021_1.PNG" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>User can dynamically configure the below parameters to the pipeline.</p>
<table border="1" class="docutils" id="id19">
<caption><span class="caption-text">Runtime parameters for the pipeline</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the blue channel.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.first 256 will be R,
next 256 values are G gamma and last 256 values are
B values</td>
</tr>
<tr class="row-odd"><td>mode_reg</td>
<td>Flag to enable/disable AWB algorithm</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are ignored while computing
min and max to improve quality.</td>
</tr>
<tr class="row-odd"><td>rows</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
</tbody>
</table>
<p>User can also use below compile time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id20">
<caption><span class="caption-text">Compiletime parameters for the pipeline</span><a class="headerlink" href="#id20" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input image.
supported formats are RGGB,BGGR,GBRG,GRBG.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                int height,
                int width,
                uint16_t rgain,
                uint16_t bgain,
                unsigned char gamma_lut[256 * 3],
                unsigned char mode_reg,
                uint16_t pawb) {

#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2

#pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

                if (!flag) {
                        ISPpipeline(img_inp, img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain, gamma_lut,
                                                mode_reg, pawb);
                        flag = 1;

                } else {
                        ISPpipeline(img_inp, img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain, gamma_lut,
                                                mode_reg, pawb);
                        flag = 0;
                }
                }

void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                        ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                        unsigned short height,
                        unsigned short width,
                        uint32_t hist0[3][HIST_SIZE],
                        uint32_t hist1[3][HIST_SIZE],
                        int gain0[3],
                        int gain1[3],
                        uint16_t rgain,
                        uint16_t bgain,
                        unsigned char gamma_lut[256 * 3],
                        unsigned char mode_reg,
                        uint16_t pawb) {

        #pragma HLS INLINE OFF

                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt; imgInput1(height, width);
                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput2(height, width);
                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; bpc_out(height, width);
                xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_3&gt; gain_out(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0&gt; demosaic_out(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_1&gt; impop(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2&gt; ltm_in(height, width);
                xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3&gt; lsc_out(height, width);
                xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4&gt; _dst(height, width);
                xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5&gt; aecin(height, width);
                xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt; _imgOutput(height, width);


        #pragma HLS DATAFLOW

                const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));
                float thresh = (float)pawb / 256;
                float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
                float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));

                xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt;(img_inp, imgInput1);
                xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_0, XF_CV_DEPTH_IN_1&gt;(imgInput1, imgInput2, BLACK_LEVEL,mul_fact);
                xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1, XF_CV_DEPTH_IN_3&gt;(imgInput2, gain_out, rgain, bgain);
                xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_IN_3, XF_CV_DEPTH_OUT_0&gt;(gain_out, demosaic_out);
                function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0, XF_CV_DEPTH_OUT_2&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,height, width, mode_reg, thresh);
                xf::cv::colorcorrectionmatrix&lt;XF_CCM_TYPE, XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2, XF_CV_DEPTH_OUT_3&gt;(ltm_in, lsc_out);
                if (XF_DST_T == XF_8UC3) {
                        fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(lsc_out, aecin, height, width);
                } else {
                        xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(lsc_out, aecin);
                }
                xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5, XF_CV_DEPTH_OUT_4&gt;(aecin, _dst, gamma_lut);
                xf::cv::rgb2yuyv&lt;XF_LTM_T, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4, XF_CV_DEPTH_OUT_6&gt;(_dst, _imgOutput);
                xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt;(_imgOutput, img_out);
        }
</pre></div>
</div>
</div>
<div class="section" id="isp-201hdr">
<span id="id12"></span><h2>Image Sensor Processing pipeline with HDR<a class="headerlink" href="#isp-201hdr" title="Permalink to this headline">¶</a></h2>
<p>This ISP includes HDR function with 2021.1 pipeline with out color space conversion. It takes two exposure frames as inputs(Short exposure frame and Long exposure frame) and
after HDR fusion it will return hdr merged output frame. The HDR output goes to ISP 2021.1 pipeline and returns the output RGB image.</p>
<ul class="simple">
<li>HDRMerge : HDRMerge module generates the Hign dynamic range image from a set of different exposure frames. Usually, image sensors has limited dynamic range and it’s difficult to get HDR image with single image capture. From the sensor, the frames are collected with different exposure times and will get different exposure frames, HDRMerge will generates the HDR frame with those exposure frames.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-hdr.PNG"><img alt="isp-hdr" class="image" src="_images/isp-hdr.PNG" style="width: 1000px;" /></a></p>
<p>The following example demonstrates the ISP pipeline with HDR.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp1,
        ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp2,
        ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
        int height,
        int width,
        uint16_t rgain,
        uint16_t bgain,
        unsigned char gamma_lut[256 * 3],
        unsigned char mode_reg,
        uint16_t pawb,
        short* wr_hls) {

#pragma HLS INTERFACE m_axi     port=img_inp1  offset=slave bundle=gmem1
#pragma HLS INTERFACE m_axi     port=img_inp2  offset=slave bundle=gmem2
#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem3
#pragma HLS INTERFACE m_axi     port=wr_hls  offset=slave bundle=gmem4

#pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

        if (!flag) {
                ISPpipeline(img_inp1, img_inp2, img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain,
                                        gamma_lut, mode_reg, pawb, wr_hls);
                flag = 1;

        } else {
                ISPpipeline(img_inp1, img_inp2, img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain,
                                        gamma_lut, mode_reg, pawb, wr_hls);
                flag = 0;
        }
}

void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp1,
                        ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp2,
                        ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                        unsigned short height,
                        unsigned short width,
                        uint32_t hist0[3][HIST_SIZE],
                        uint32_t hist1[3][HIST_SIZE],
                        int gain0[3],
                        int gain1[3],
                        uint16_t rgain,
                        uint16_t bgain,
                        unsigned char gamma_lut[256 * 3],
                        unsigned char mode_reg,
                        uint16_t pawb,
                        short* wr_hls) {

#pragma HLS INLINE OFF

        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR1&gt; imgInputhdr1(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR2&gt; imgInputhdr2(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput1(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; imgInput2(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_BPC_OUT&gt; bpc_out(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_GAIN_OUT&gt; gain_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DEMOSAIC_OUT&gt; demosaic_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IMPOP&gt; impop(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LTM_IN&gt; ltm_in(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LSC_OUT&gt; lsc_out(height, width);
        xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST&gt; _dst(height, width);
        xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_AEC_IN&gt; aecin(height, width);
        xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT&gt; _imgOutput(height, width);


#pragma HLS DATAFLOW

        const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));
        float thresh = (float)pawb / 256;
        float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
        float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));
        xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR1&gt;(img_inp1, imgInputhdr1);
        xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR2&gt;(img_inp2, imgInputhdr2);

        xf::cv::Hdrmerge_bayer&lt;XF_SRC_T, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR1, XF_CV_DEPTH_IN_DR2, NO_EXPS, W_B_SIZE&gt;(
                imgInputhdr1, imgInputhdr2, imgInput1, wr_hls);

        xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_1, XF_CV_DEPTH_IN_2&gt;(imgInput1, imgInput2, BLACK_LEVEL,mul_fact);
        xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2, XF_CV_DEPTH_GAIN_OUT&gt;(imgInput2, gain_out, rgain, bgain);
        xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_GAIN_OUT,XF_CV_DEPTH_DEMOSAIC_OUT&gt;(gain_out, demosaic_out);
        function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DEMOSAIC_OUT, XF_CV_DEPTH_LTM_IN&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,height, width, mode_reg, thresh);
        xf::cv::colorcorrectionmatrix&lt;XF_CCM_TYPE, XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LTM_IN, XF_CV_DEPTH_LSC_OUT&gt;(ltm_in, lsc_out);
        if (XF_DST_T == XF_8UC3) {
                fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LSC_OUT, XF_CV_DEPTH_AEC_IN&gt;(lsc_out, aecin, height, width);
        } else {
                xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPC, XF_CV_DEPTH_LSC_OUT, XF_CV_DEPTH_AEC_IN&gt;(lsc_out, aecin);
        }
        xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_AEC_IN, XF_CV_DEPTH_DST&gt;(aecin, _dst, gamma_lut);
        xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_8UC3, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST&gt;(_dst, img_out);
}
</pre></div>
</div>
</div>
<div class="section" id="isp-201gtm">
<span id="id13"></span><h2>Image Sensor Processing pipeline with GTM<a class="headerlink" href="#isp-201gtm" title="Permalink to this headline">¶</a></h2>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>Black level correction : Black level leads to the whitening of image in dark region and perceived loss of overall
contrast. The Blacklevelcorrection algorithm corrects the black and white levels of the overall image.</li>
<li>BPC (Bad pixel correction) : An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control : The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing : The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
<li>Colorcorrection matrix : corrects color suitable for display or video system.</li>
<li>Global tone mapping : Reduces the dynamic range from higher range to display range using tone mapping.</li>
<li>Gamma correction : Gamma correction improves the overall brightness of image.</li>
<li>Color space conversion : Converting RGB image to YUV422(YUYV) image for HDMI display purpose.RGB2YUYV converts the RGB image into Y channel for every pixel and U and V for alternate pixels.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-gtm.png"><img alt="isp-gtm" class="image" src="_images/isp-gtm.png" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>User can dynamically configure the below parameters to the pipeline.</p>
<table border="1" class="docutils" id="id21">
<caption><span class="caption-text">Runtime parameters for the pipeline</span><a class="headerlink" href="#id21" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the blue channel.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.first 256 will be R,
next 256 values are G gamma and last 256 values are
B values</td>
</tr>
<tr class="row-odd"><td>mode_reg</td>
<td>Flag to enable/disable AWB algorithm</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are ignored while computing
min and max to improve quality.</td>
</tr>
<tr class="row-odd"><td>rows</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
<tr class="row-odd"><td>c1</td>
<td>To retain the details in bright area using, c1 in the
tone mapping.</td>
</tr>
<tr class="row-even"><td>c2</td>
<td>Efficiency factor, ranges from 0.5 to 1 based on
output device dynamic range.</td>
</tr>
</tbody>
</table>
<p>User can also use below compile time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id22">
<caption><span class="caption-text">Compiletime parameters for the pipeline</span><a class="headerlink" href="#id22" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input image.
supported formats are RGGB,BGGR,GBRG,GRBG.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                    ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                    int height,
                    int width,
                    uint16_t rgain,
                    uint16_t bgain,
                    unsigned char gamma_lut[256 * 3],
                    unsigned char mode_reg,
                    uint16_t pawb,
float c1,
float c2) {

    #pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
    #pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2

    #pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
    #pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

                    if (!flag) {
                              ISPpipeline(img_inp, img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain, gamma_lut,
                                                      mode_reg, pawb, mean2, mean1, L_max2, L_max1, L_min2, L_min1, c1, c2);
                              flag = 1;

                    } else {
                              ISPpipeline(img_inp, img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain, gamma_lut,
                                                      mode_reg, pawb, mean1, mean2, L_max1, L_max2, L_min1, L_min2, c1, c2);
                              flag = 0;
                    }
                    }

    void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                            ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                            unsigned short height,
                            unsigned short width,
                            uint32_t hist0[3][HIST_SIZE],
                            uint32_t hist1[3][HIST_SIZE],
                            int gain0[3],
                            int gain1[3],
                            uint16_t rgain,
                            uint16_t bgain,
                            unsigned char gamma_lut[256 * 3],
                            unsigned char mode_reg,
                            uint16_t pawb,
    ap_ufixed&lt;16, 4&gt;&amp; mean1,
    ap_ufixed&lt;16, 4&gt;&amp; mean2,
    ap_ufixed&lt;16, 4&gt;&amp; L_max1,
    ap_ufixed&lt;16, 4&gt;&amp; L_max2,
    ap_ufixed&lt;16, 4&gt;&amp; L_min1,
    ap_ufixed&lt;16, 4&gt;&amp; L_min2,
    float c1,
    float c2) {

            #pragma HLS INLINE OFF

                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt; imgInput1(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput2(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; bpc_out(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_3&gt; gain_out(height, width);
                    xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0&gt; demosaic_out(height, width);
                    xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_1&gt; impop(height, width);
                    xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2&gt; ltm_in(height, width);
                    xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3&gt; lsc_out(height, width);
                    xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4&gt; _dst(height, width);
                    xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5&gt; aecin(height, width);
                    xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt; _imgOutput(height, width);


            #pragma HLS DATAFLOW

                    const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));
                    float thresh = (float)pawb / 256;
                    float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
                    float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));

                    xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt;(img_inp, imgInput1);
                    xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_0, XF_CV_DEPTH_IN_1&gt;(imgInput1, imgInput2, BLACK_LEVEL,mul_fact);
                    xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPCC, XF_CV_DEPTH_IN_1,&gt;(imgInput2, gain_out, rgain, bgain);
                    xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_IN_3, XF_CV_DEPTH_OUT_0&gt;(gain_out, demosaic_out);
                    function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0, XF_CV_DEPTH_OUT_2&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,height, width, mode_reg, thresh);
                    xf::cv::colorcorrectionmatrix&lt;XF_CCM_TYPE, XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2, XF_CV_DEPTH_OUT_3&gt;(ltm_in, lsc_out);

                    if (XF_DST_T == XF_8UC3) {
                            fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(lsc_out, aecin, height, width);
                    } else {
                             xf::cv::gtm&lt;XF_DST_T, XF_LTM_T, XF_SRC_T, SIN_CHANNEL_TYPE, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(
     lsc_out, aecin, mean1, mean2, L_max1, L_max2, L_min1, L_min2, c1, c2, height, width);
                    }
                    xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5, XF_CV_DEPTH_OUT_4&gt;(aecin, _dst, gamma_lut);
                    xf::cv::rgb2yuyv&lt;XF_LTM_T, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4, XF_CV_DEPTH_OUT_6&gt;(_dst, _imgOutput);
                    xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt;(_imgOutput, img_out);
            }
</pre></div>
</div>
</div>
<div class="section" id="isp-201mono">
<span id="id14"></span><h2>Mono image Sensor Processing pipeline<a class="headerlink" href="#isp-201mono" title="Permalink to this headline">¶</a></h2>
<p>The Mono image sensor is different when compared to RGB Bayer sensor. Few applications does not need color information, in such cases user can use mono image
sensor instead of color sensor. The mono image sensor pipeline has lot of advantages compared to color sensor processing , computational cost and higher resolution because of
single channel and also reduce errors occured while doing image reconstruction using demosaic in the color sensor processing.</p>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>Black level correction : Black level leads to the whitening of image in dark region and perceived loss of overall
contrast. The Blacklevelcorrection algorithm corrects the black and white levels of the overall image.</li>
<li>BPC (Bad pixel correction) : Using median filter for BPC. An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control : The Gain control module improves the overall brightness of the image.</li>
<li>Quantization and Dithering : Quantization and Dithering performs the uniform quantization to also reduce higher bit depth to lower bit depths.</li>
<li>Gamma correction : Gamma correction improves the overall brightness of image.</li>
<li>Autoexposure correction : Using CLAHE algorithm to improve brightness and contrast of the image.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-mono.png"><img alt="isp-mono" class="image" src="_images/isp-mono.png" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>User can dynamically configure the below parameters to the pipeline.</p>
<table border="1" class="docutils" id="id23">
<caption><span class="caption-text">Runtime parameters for the pipeline</span><a class="headerlink" href="#id23" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lgain</td>
<td>To configure gain value for the luminence channel.</td>
</tr>
<tr class="row-odd"><td>gamma_lut</td>
<td>Lookup table for gamma values.</td>
</tr>
<tr class="row-even"><td>rows</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-odd"><td>cols</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
<tr class="row-even"><td>clip</td>
<td>clip is used to set the threshold for contrast limit
in the processing</td>
</tr>
<tr class="row-odd"><td>tilesY</td>
<td>The image is divided into tiles in the CLAHE. The
tilesY represents the number of tiles in Y direction.</td>
</tr>
<tr class="row-even"><td>tilesX</td>
<td>The image is divided into tiles in the CLAHE. The
tilesY represents the number of tiles in X direction.</td>
</tr>
</tbody>
</table>
<p>User can also use below compile time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id24">
<caption><span class="caption-text">Compiletime parameters for the pipeline</span><a class="headerlink" href="#id24" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_SRC_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>       void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                          ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                          int height,
                                          int width,
                                          uint16_t lgain,
                                          unsigned char gamma_lut[256],
                                          int clip,
                                          int tilesY,
                                          int tilesX) {

       #pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
       #pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2
       #pragma HLS INTERFACE m_axi      port=gamma_lut offset=slave  bundle=gmem3 depth=256

       #pragma HLS INTERFACE s_axilite  port=clip
       #pragma HLS INTERFACE s_axilite  port=tilesY
       #pragma HLS INTERFACE s_axilite  port=tilesX
       #pragma HLS INTERFACE s_axilite  port=return

       #pragma HLS ARRAY_PARTITION variable=_lut1 dim=3 complete
       #pragma HLS ARRAY_PARTITION variable=_lut2 dim=3 complete


                       if (!flag) {
                               ISPpipeline(img_inp, img_out, height, width, lgain, gamma_lut, _lut1, _lut2, _clipCounter, clip, tilesX,
                                                       tilesY);
                               flag = 1;

                       } else {
                               ISPpipeline(img_inp, img_out, height, width, lgain, gamma_lut, _lut2, _lut1, _clipCounter, clip, tilesX,
                                                       tilesY);
                               flag = 0;
                       }
               }

       void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
unsigned short height,
unsigned short width,
uint16_t lgain,
unsigned char gamma_lut[256],
ap_uint&lt;HIST_COUNTER_BITS&gt; _lutw[TILES_Y_MAX][TILES_X_MAX][(XF_NPIXPERCYCLE(XF_NPPC) &lt;&lt; 1)]
                                [1 &lt;&lt; XF_DTPIXELDEPTH(XF_LTM_T, XF_NPPC)],
ap_uint&lt;HIST_COUNTER_BITS&gt; _lutr[TILES_Y_MAX][TILES_X_MAX][(XF_NPIXPERCYCLE(XF_NPPC) &lt;&lt; 1)]
                                [1 &lt;&lt; XF_DTPIXELDEPTH(XF_LTM_T, XF_NPPC)],
ap_uint&lt;CLIP_COUNTER_BITS&gt; _clipCounter[TILES_Y_MAX][TILES_X_MAX],
int clip,
int tilesY,
int tilesX) {

               #pragma HLS INLINE OFF

                       xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput1(height, width);
                       xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; imgInput2(height, width);
                       xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DPC_OUT&gt; dpc_out(height, width);
                       xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_GAIN_OUT&gt; gain_out(height, width);
                       xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IMPOP&gt; impop(height, width);
                       xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST&gt; _dst(height, width);
                       xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_AEC_IN&gt; aecin(height, width);
                       xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT&gt; _imgOutput(height, width);


               #pragma HLS DATAFLOW


                       CLAHE_T obj;

                       const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));

                       float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1;

                       float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));

                       xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt;(img_inp, imgInput1);
                       xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_1, XF_CV_DEPTH_IN_2&gt;(imgInput1, imgInput2, BLACK_LEVEL,
                                                                                                                                                                                       mul_fact);

                       xf::cv::medianBlur&lt;WINDOW_SIZE, XF_BORDER_REPLICATE, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2, XF_CV_DEPTH_DPC_OUT&gt;(imgInput2, dpc_out);
                       xf::cv::gaincontrol_mono&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DPC_OUT, XF_CV_DEPTH_GAIN_OUT&gt;(dpc_out, gain_out, lgain);

                       if (XF_DST_T == XF_8UC1) {
                               fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_GAIN_OUT, XF_CV_DEPTH_AEC_IN&gt;(gain_out, aecin, height, width);
                       } else {
                               xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPC, XF_CV_DEPTH_GAIN_OUT, XF_CV_DEPTH_AEC_IN&gt;(gain_out, aecin);
                       }

                       obj.process(_dst, aecin, _lutw, _lutr, _clipCounter, height, width, clip, tilesY, tilesX);

                       xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST, XF_CV_DEPTH_OUT&gt;(_dst, _imgOutput, gamma_lut);

                       xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT&gt;(_imgOutput, img_out);
               }
</pre></div>
</div>
</div>
<div class="section" id="isp-201rgbir">
<span id="id15"></span><h2>RGB-IR image Sensor Processing pipeline<a class="headerlink" href="#isp-201rgbir" title="Permalink to this headline">¶</a></h2>
<p>This Image Sensor Processing (ISP) pipeline works on a raw bayer pattern image that has IR data at some pixel loactions. It creates a fully processed RGB image and an IR image.</p>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>RGBIR to Bayer : This module converts the input image with R,G,B,IR pixel data into a standard bayer pattern image along with a full IR data image.</li>
<li>Gain Control : The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing : The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
<li>Quantization and Dithering : Quantization and Dithering performs the uniform quantization to also reduce higher bit depth to lower bit depths.</li>
<li>Gamma correction : Gamma correction improves the overall brightness of image.</li>
<li>Color space conversion : Converting RGB image to YUV422(YUYV) image for HDMI display purpose.RGB2YUYV converts the RGB image into Y channel for every pixel and U and V for alternate pixels.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-rgbir.png"><img alt="isp-rgbir" class="image" src="_images/isp-rgbir.png" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>User can dynamically configure the below parameters to the pipeline.</p>
<table border="1" class="docutils" id="id25">
<caption><span class="caption-text">Runtime parameters for the pipeline</span><a class="headerlink" href="#id25" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the blue channel.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.first 256 will be R,
next 256 values are G gamma and last 256 values are
B values</td>
</tr>
<tr class="row-odd"><td>mode_reg</td>
<td>Flag to enable/disable AWB algorithm</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are ignored while computing
min and max to improve quality.</td>
</tr>
<tr class="row-odd"><td>height</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-even"><td>width</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
<tr class="row-odd"><td>R_IR_C1_Wgts</td>
<td>5x5 Weights to calculate R at IR location for constellation1</td>
</tr>
<tr class="row-even"><td>R_IR_C2_Wgts</td>
<td>5x5 Weights to calculate R at IR location for constellation2</td>
</tr>
<tr class="row-odd"><td>B_at_R_wgts</td>
<td>5x5 Weights to calculate B at R location</td>
</tr>
<tr class="row-even"><td>IR_at_R_wgts</td>
<td>3x3 Weights to calculate IR at R location</td>
</tr>
<tr class="row-odd"><td>IR_at_B_wgts</td>
<td>3x3 Weights to calculate IR at B location</td>
</tr>
<tr class="row-even"><td>sub_wgts</td>
<td>Weights to perform weighted subtraction of IR
image from RGB image. sub_wgts[0] -&gt; G Pixel,
sub_wgts[1] -&gt; R Pixel, sub_wgts[2] -&gt; B Pixel
sub_wgts[3] -&gt; calculated B Pixel</td>
</tr>
</tbody>
</table>
<p>User can also use below compile time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id26">
<caption><span class="caption-text">Compiletime parameters for the pipeline</span><a class="headerlink" href="#id26" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input image.
Supported formats are BGGR, GRBG.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type;supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>extern &quot;C&quot; {
void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                           ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                           ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* ir_img_out,
                                           int height,
                                           int width,
                                           uint16_t rgain,
                                           uint16_t bgain,
                                           char R_IR_C1_wgts[25],
                                           char R_IR_C2_wgts[25],
                                           char B_at_R_wgts[25],
                                           char IR_at_R_wgts[9],
                                           char IR_at_B_wgts[9],
                                           char sub_wgts[4],
                                           unsigned char gamma_lut[256 * 3],
                                           unsigned char mode_reg,
                                           uint16_t pawb) {
// clang-format off
#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2
#pragma HLS INTERFACE m_axi     port=ir_img_out  offset=slave bundle=gmem3
#pragma HLS INTERFACE m_axi     port=R_IR_C1_wgts  offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi     port=R_IR_C2_wgts  offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi     port=B_at_R_wgts  offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi     port=IR_at_R_wgts  offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi     port=IR_at_B_wgts  offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi     port=sub_wgts  offset=slave bundle=gmem5
#pragma HLS INTERFACE m_axi     port=gamma_lut  offset=slave bundle=gmem6

// clang-format on

// clang-format off
#pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

        // clang-format on

        if (!flag) {
                ISPpipeline(img_inp, img_out, ir_img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain,
                                        R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, gamma_lut, mode_reg,
                                        pawb);
                flag = 1;

        } else {
                ISPpipeline(img_inp, img_out, ir_img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain,
                                        R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, gamma_lut, mode_reg,
                                        pawb);
                flag = 0;
        }
}

void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                 ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                 ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* ir_img_out,
                                 unsigned short height,
                                 unsigned short width,
                                 uint32_t hist0[3][HIST_SIZE],
                                 uint32_t hist1[3][HIST_SIZE],
                                 int gain0[3],
                                 int gain1[3],
                                 uint16_t rgain,
                                 uint16_t bgain,
                                 char R_IR_C1_wgts[25],
                                 char R_IR_C2_wgts[25],
                                 char B_at_R_wgts[25],
                                 char IR_at_R_wgts[9],
                                 char IR_at_B_wgts[9],
                                 char sub_wgts[4],
                                 unsigned char gamma_lut[256 * 3],
                                 unsigned char mode_reg,
                                 uint16_t pawb) {
// clang-format off
#pragma HLS INLINE OFF
        // clang-format on
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInput&gt; imgInput(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInputCopy1&gt; imgInputCopy1(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInputCopy2&gt; imgInputCopy2(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_fullir_out&gt; fullir_out(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_rggb_out&gt; rggb_out(height, width);
        xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_gain_out&gt; gain_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_demosaic_out&gt; demosaic_out(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_demoOut_final&gt; demoOut_final(height, width);
        xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_ltm_in&gt; ltm_in(height, width);
        xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__dst&gt; _dst(height, width);
        xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_aecin&gt; aecin(height, width);
        xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__imgOutput&gt; _imgOutput(height, width);

// clang-format off
#pragma HLS DATAFLOW
        // clang-format on
        const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));

        float thresh = (float)pawb / 256;
        float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;

        float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));

        xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInput&gt;(img_inp, imgInput);

        xf::cv::rgbir2bayer&lt;FILTERSIZE1, FILTERSIZE2, XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_BORDER_CONSTANT, XF_USE_URAM, XF_CV_DEPTH_imgInput, XF_CV_DEPTH_rggb_out, XF_CV_DEPTH_fullir_out, XF_CV_DEPTH_3XWIDTH&gt;(
                imgInput, R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, rggb_out, fullir_out);

        xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_rggb_out, XF_CV_DEPTH_gain_out&gt;(rggb_out, gain_out, rgain, bgain);
        xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_gain_out, XF_CV_DEPTH_demosaic_out&gt;(gain_out, demosaic_out);

        function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_demosaic_out, XF_CV_DEPTH_ltm_in&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1, height, width, mode_reg, thresh);

        if (XF_DST_T == XF_8UC3) {
                fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_ltm_in, XF_CV_DEPTH_aecin&gt;(ltm_in, aecin, height, width);
        } else {
                xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPCXF_CV_DEPTH_ltm_in, XF_CV_DEPTH_aecin&gt;(ltm_in, aecin);
        }
        xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_aecin, XF_CV_DEPTH__dst&gt;(aecin, _dst, gamma_lut);
        xf::cv::rgb2yuyv&lt;XF_LTM_T, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__dst, XF_CV_DEPTH__imgOutput&gt;(_dst, _imgOutput);

        xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__imgOutput&gt;(_imgOutput, img_out);
        xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_fullir_out&gt;(fullir_out, ir_img_out);
}
</pre></div>
</div>
</div>
<div class="section" id="isp-201multistream">
<span id="id16"></span><h2>Image Sensor Processing multistream pipeline - 2022.1 version<a class="headerlink" href="#isp-201multistream" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div>ISP multistream pipeline allows user to process input from multi streams using one instance of ISP.
Current multi stream pipeline process 4 streams in a Round-Robin method with ouput steams TYPE as XF_8UC3(RGB). And after the color conversion to YUV color space, they are XF_16UC1(YUYV).</div></blockquote>
<p>This ISP pipeline inclues 8 blocks, they are following:</p>
<ul class="simple">
<li>Black level correction</li>
<li>Gain Control</li>
<li>Demosaicing</li>
<li>Auto white balance</li>
<li>Colorcorrection matrix</li>
<li>Quantization and Dithering</li>
<li>Gamma correction</li>
<li>Color space conversion</li>
</ul>
<p>Note: CCM and Q&amp;D currently supports one output type for all the streams. Upcoming versions will support different output types.</p>
<p><a class="image reference internal" href="_images/isp-2022_1.png"><img alt="isp-20221" class="image" src="_images/isp-2022_1.png" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>User can dynamically configure the below parameters to the pipeline.</p>
<table border="1" class="docutils" id="id27">
<caption><span class="caption-text">Runtime parameters for the pipeline</span><a class="headerlink" href="#id27" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>blacklevel</td>
<td>black level value to adjustment overall brightness
of the image</td>
</tr>
<tr class="row-odd"><td>rgain</td>
<td>To configure gain value for the red channel.</td>
</tr>
<tr class="row-even"><td>bgain</td>
<td>To configure gain value for the blue channel.</td>
</tr>
<tr class="row-odd"><td>ggain</td>
<td>To configure gain value for the green channel.</td>
</tr>
<tr class="row-even"><td>bayer pattern</td>
<td>The Bayer format of the RAW input image.
supported formats are RGGB, BGGR, GBRG, GRBG</td>
</tr>
<tr class="row-odd"><td>gamma_lut</td>
<td>Lookup table for gamma values.first 256 will be R,
next 256 values are G gamma and last 256 values are
B values</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are ignored while computing
min and max to improve quality.</td>
</tr>
<tr class="row-odd"><td>rows</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
</tbody>
</table>
<p>User can also use below compile time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id28">
<caption><span class="caption-text">Compiletime parameters for the pipeline</span><a class="headerlink" href="#id28" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_SRC_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
<tr class="row-odd"><td>NUM_STREAMS</td>
<td>Total number of streams</td>
</tr>
<tr class="row-even"><td>STRM1_ROWS</td>
<td>maximum number of rows to be processed for stream 1
in one burst</td>
</tr>
<tr class="row-odd"><td>STRM2_ROWS</td>
<td>maximum number of rows to be processed for stream 2
in one burst</td>
</tr>
<tr class="row-even"><td>STRM3_ROWS</td>
<td>maximum number of rows to be processed for stream 3
in one burst</td>
</tr>
<tr class="row-odd"><td>STRM4_ROWS</td>
<td>maximum number of rows to be processed for stream 4
in one burst</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">void</span> <span class="n">ISPPipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp1</span><span class="p">,</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp2</span><span class="p">,</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp3</span><span class="p">,</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp4</span><span class="p">,</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out1</span><span class="p">,</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out2</span><span class="p">,</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out3</span><span class="p">,</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out4</span><span class="p">,</span>
<span class="nb">int</span> <span class="n">height</span><span class="p">,</span>
<span class="nb">int</span> <span class="n">width</span><span class="p">,</span>
<span class="n">unsigned</span> <span class="n">short</span> <span class="n">array_params</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">6</span><span class="p">],</span>
<span class="n">unsigned</span> <span class="n">char</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">3</span><span class="p">])</span> <span class="p">{</span>
         <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp1  offset=slave bundle=gmem1</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp2  offset=slave bundle=gmem2</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp3  offset=slave bundle=gmem3</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp4  offset=slave bundle=gmem4</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_out1  offset=slave bundle=gmem5</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_out2  offset=slave bundle=gmem6</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_out3  offset=slave bundle=gmem7</span>
         <span class="c1">#pragma HLS INTERFACE m_axi     port=img_out4  offset=slave bundle=gmem8</span>
         <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

         <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
         <span class="c1">#pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1</span>
         <span class="c1">#pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1</span>
                 <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

                 <span class="n">struct</span> <span class="n">ispparams_config</span> <span class="n">params</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">];</span>

                 <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
         <span class="c1">#pragma HLS UNROLL</span>
                 <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

                         <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rgain</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
                         <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">bgain</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
                         <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ggain</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
                         <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pawb</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
                         <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">bayer_p</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>
                         <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">black_level</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">5</span><span class="p">];</span>
                 <span class="p">}</span>

                 <span class="n">uint32_t</span> <span class="n">tot_rows</span> <span class="o">=</span> <span class="n">NUM_STREAMS</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
                 <span class="n">const</span> <span class="n">uint16_t</span> <span class="n">pt</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">STRM1_ROWS</span><span class="p">,</span> <span class="n">STRM2_ROWS</span><span class="p">,</span> <span class="n">STRM3_ROWS</span><span class="p">,</span> <span class="n">STRM4_ROWS</span><span class="p">};</span>
                 <span class="n">uint16_t</span> <span class="nb">max</span> <span class="o">=</span> <span class="n">STRM1_ROWS</span><span class="p">;</span>
                 <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>

                         <span class="k">if</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">)</span>
                                 <span class="nb">max</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                 <span class="p">}</span>

                 <span class="n">const</span> <span class="n">uint16_t</span> <span class="n">TC</span> <span class="o">=</span> <span class="n">tot_rows</span> <span class="o">/</span> <span class="nb">max</span><span class="p">;</span>

                 <span class="n">uint32_t</span> <span class="n">addrbound</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">;</span>

                 <span class="nb">int</span> <span class="n">strm_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                 <span class="nb">int</span> <span class="n">rem_rows</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">height</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">height</span><span class="p">};</span>

                 <span class="n">uint32_t</span> <span class="n">offset1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                 <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">tot_rows</span><span class="p">;)</span> <span class="p">{</span>
         <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
                         <span class="c1">#pragma HLS LOOP_TRIPCOUNT min=0 max=TC</span>
                         <span class="c1">#pragma HLS LOOP_FLATTEN off</span>
                         <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

                         <span class="o">//</span> <span class="n">Compute</span> <span class="n">no</span><span class="o">.</span><span class="n">of</span> <span class="n">rows</span> <span class="n">to</span> <span class="n">process</span>
                         <span class="k">if</span> <span class="p">(</span><span class="n">rem_rows</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pt</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                                 <span class="n">num_rows</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
                         <span class="k">else</span>
                                 <span class="n">num_rows</span> <span class="o">=</span> <span class="n">rem_rows</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

                         <span class="o">//</span> <span class="n">Compute</span>
                         <span class="n">addrbound</span> <span class="o">=</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">));</span>
                         <span class="n">strm_id</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>

                         <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                                 <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp1</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">,</span> <span class="n">img_out1</span> <span class="o">+</span> <span class="n">offset1</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">hist1_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                            <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">flag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
                                 <span class="n">offset1</span> <span class="o">+=</span> <span class="n">addrbound</span><span class="p">;</span>
                         <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                                 <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp2</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">,</span> <span class="n">img_out2</span> <span class="o">+</span> <span class="n">offset2</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">hist1_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                            <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">flag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

                                 <span class="n">offset2</span> <span class="o">+=</span> <span class="n">addrbound</span><span class="p">;</span>
                         <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                                 <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp3</span> <span class="o">+</span> <span class="n">offset3</span><span class="p">,</span> <span class="n">img_out3</span> <span class="o">+</span> <span class="n">offset3</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">hist1_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                            <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">flag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

                                 <span class="n">offset3</span> <span class="o">+=</span> <span class="n">addrbound</span><span class="p">;</span>
                         <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                                 <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp4</span> <span class="o">+</span> <span class="n">offset4</span><span class="p">,</span> <span class="n">img_out4</span> <span class="o">+</span> <span class="n">offset4</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">hist1_awb</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                            <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">flag</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>

                                 <span class="n">offset4</span> <span class="o">+=</span> <span class="n">addrbound</span><span class="p">;</span>
                         <span class="p">}</span>
                         <span class="o">//</span> <span class="n">Update</span> <span class="n">remaining</span> <span class="n">rows</span> <span class="n">to</span> <span class="n">process</span>
                         <span class="n">rem_rows</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem_rows</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_rows</span><span class="p">;</span>

                         <span class="o">//</span> <span class="n">Next</span> <span class="n">stream</span> <span class="n">selection</span>
                         <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">NUM_STREAMS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                                 <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                         <span class="k">else</span>
                                 <span class="n">idx</span><span class="o">++</span><span class="p">;</span>

                         <span class="o">//</span> <span class="n">Update</span> <span class="n">total</span> <span class="n">rows</span> <span class="n">to</span> <span class="n">process</span>
                         <span class="n">r</span> <span class="o">+=</span> <span class="n">num_rows</span><span class="p">;</span>
                 <span class="p">}</span>

                 <span class="k">return</span><span class="p">;</span>
         <span class="p">}</span>

 <span class="n">void</span> <span class="n">Streampipeline</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp</span><span class="p">,</span>
                                         <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
                                         <span class="n">unsigned</span> <span class="n">short</span> <span class="n">height</span><span class="p">,</span>
                                         <span class="n">unsigned</span> <span class="n">short</span> <span class="n">width</span><span class="p">,</span>
                                         <span class="n">uint32_t</span> <span class="n">hist0</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">HIST_SIZE</span><span class="p">],</span>
                                         <span class="n">uint32_t</span> <span class="n">hist1</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">HIST_SIZE</span><span class="p">],</span>
                                         <span class="nb">int</span> <span class="n">gain0</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                         <span class="nb">int</span> <span class="n">gain1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                         <span class="n">struct</span> <span class="n">ispparams_config</span> <span class="n">params</span><span class="p">,</span>
                                         <span class="n">unsigned</span> <span class="n">char</span> <span class="n">_gamma_lut</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>
                                         <span class="nb">bool</span> <span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="o">&gt;</span> <span class="n">imgInput</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_1</span><span class="o">&gt;</span> <span class="n">blc_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_2</span><span class="o">&gt;</span> <span class="n">bpc_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_3</span><span class="o">&gt;</span> <span class="n">gain_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_0</span><span class="o">&gt;</span> <span class="n">demosaic_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_1</span><span class="o">&gt;</span> <span class="n">impop</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span> <span class="n">ltm_in</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_3</span><span class="o">&gt;</span> <span class="n">lsc_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_4</span><span class="o">&gt;</span> <span class="n">_dst</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_5</span><span class="o">&gt;</span> <span class="n">aecin</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_6</span><span class="o">&gt;</span> <span class="n">imgOutput</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>

 <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
 <span class="c1">#pragma HLS DATAFLOW</span>
         <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
         <span class="n">const</span> <span class="nb">int</span> <span class="n">Q_VAL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">XF_DTPIXELDEPTH</span><span class="p">(</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">));</span>

         <span class="nb">float</span> <span class="n">thresh</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">params</span><span class="o">.</span><span class="n">pawb</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
         <span class="nb">float</span> <span class="n">inputMax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">XF_DTPIXELDEPTH</span><span class="p">(</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">//</span> <span class="mf">65535.0</span><span class="n">f</span><span class="p">;</span>

         <span class="nb">float</span> <span class="n">mul_fact</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputMax</span> <span class="o">/</span> <span class="p">(</span><span class="n">inputMax</span> <span class="o">-</span> <span class="n">params</span><span class="o">.</span><span class="n">black_level</span><span class="p">));</span>

         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">imgInput</span><span class="p">);</span>

         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">blackLevelCorrection</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput</span><span class="p">,</span> <span class="n">blc_out</span><span class="p">,</span>
                                                                                                                                                                           <span class="n">params</span><span class="o">.</span><span class="n">black_level</span><span class="p">,</span> <span class="n">mul_fact</span><span class="p">);</span>
         <span class="o">//</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">badpixelcorrection</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput2</span><span class="p">,</span> <span class="n">bpc_out</span><span class="p">);</span>

         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">gaincontrol</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">blc_out</span><span class="p">,</span> <span class="n">gain_out</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">rgain</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">bgain</span><span class="p">,</span>
                                                                                                                                   <span class="n">params</span><span class="o">.</span><span class="n">ggain</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">bayer_p</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">demosaicing</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_3</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gain_out</span><span class="p">,</span> <span class="n">demosaic_out</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">bayer_p</span><span class="p">);</span>

         <span class="n">function_awb</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_0</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">demosaic_out</span><span class="p">,</span> <span class="n">ltm_in</span><span class="p">,</span> <span class="n">hist0</span><span class="p">,</span> <span class="n">hist1</span><span class="p">,</span> <span class="n">gain0</span><span class="p">,</span> <span class="n">gain1</span><span class="p">,</span>
                                                                                                                                          <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">colorcorrectionmatrix</span><span class="o">&lt;</span><span class="n">XF_CCM_TYPE</span><span class="p">,</span> <span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ltm_in</span><span class="p">,</span> <span class="n">lsc_out</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">XF_DST_T</span> <span class="o">==</span> <span class="n">XF_8UC3</span><span class="p">)</span> <span class="p">{</span>
                 <span class="n">fifo_copy</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_3</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lsc_out</span><span class="p">,</span> <span class="n">aecin</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                 <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xf_QuatizationDithering</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">Q_VAL</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_3</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_5</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lsc_out</span><span class="p">,</span> <span class="n">aecin</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">gammacorrection</span><span class="o">&lt;</span><span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPP</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_5</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_4C</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aecin</span><span class="p">,</span> <span class="n">_dst</span><span class="p">,</span> <span class="n">_gamma_lut</span><span class="p">);</span>
         <span class="o">//</span> <span class="n">ColorMat2AXIvideo</span><span class="o">&lt;</span><span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_dst</span><span class="p">,</span> <span class="n">m_axis_video</span><span class="p">);</span>
         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">rgb2yuyv</span><span class="o">&lt;</span><span class="n">XF_LTM_T</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_4</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_6</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_dst</span><span class="p">,</span> <span class="n">imgOutput</span><span class="p">);</span>

         <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">STRM_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_6</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>

         <span class="k">return</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>The ISP multistream Pipeline design is validated on Alveo U200 board at 300 MHz frequency.</p>
<table border="1" class="docutils" id="id29">
<caption><span class="caption-text">Table Resource Utilization Summary</span><a class="headerlink" href="#id29" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="15%" />
<col width="15%" />
<col width="20%" />
<col width="21%" />
<col width="10%" />
<col width="7%" />
<col width="7%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head" rowspan="2">Filter size</th>
<th class="head" rowspan="2"><p class="first">Operating Frequency</p>
<p class="last">(MHz)</p>
</th>
<th class="head" colspan="5">Utilization Estimate</th>
</tr>
<tr class="row-even"><th class="head">BRAM_18K</th>
<th class="head">DSP</th>
<th class="head">FF</th>
<th class="head">LUT</th>
<th class="head">URAM</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>2 Pixel</td>
<td>3x3</td>
<td>300</td>
<td>29</td>
<td>69</td>
<td>21230</td>
<td>18332</td>
<td>0</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id30">
<caption><span class="caption-text">Table Performance Estimate Summary</span><a class="headerlink" href="#id30" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="29%" />
<col width="38%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head" rowspan="2"><p class="first">Operating Frequency</p>
<p class="last">(MHz)</p>
</th>
<th class="head">Latency Estimate</th>
</tr>
<tr class="row-even"><th class="head">Max (ms)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>2 pixel</td>
<td>300</td>
<td>17.9ms</td>
</tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>

        </div>
      </div>


	  <!-- Sphinx Page Footer block -->
  

  <hr/>

  <div role="contentinfo" class="copyright">
    <p class="footerinfo">
      <span class="lastupdated">
        Last updated on August 02, 2022.
      </span>

    </p>
	<br>
  </div>
      </div>
    </section>


  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

   <script type="text/javascript">
    jQuery(function() { Search.loadIndex("searchindex.js"); });
  </script>

  <script type="text/javascript" id="searchindexloader"></script>


  
  
    
  



  <!--  Xilinx template footer block -->
							</div>
						</div>
					</div>
				</div>
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="footer parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
								<noindex>
                  <!-- make footer fixed - NileshP -->
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
                  <!-- make footer fixed NileshP-->
									<footer>
										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">
													<div class="row">
														<div class="footerSocial parbase">
														
															<div class="col-md-push-6 col-lg-push-6 col-md-6 col-lg-6">
																<div class="lang-select dropup hidden-md hidden-lg">
		<button data-toggle="dropdown">
			<span class="fas fa-globe" aria-hidden="true"></span>
			<span>
				
					English
				</span>
		<span class="far fa-angle-down" aria-hidden="true"></span>
	</button>
	<ul class="dropdown-menu">
		<li>
				<a target="_blank" href="https://japan.xilinx.com/" target="_self">
					日本語
				</a>
			</li>
		<li>
				<a target="_blank" href="https://china.xilinx.com/" target="_self">
					简体中文
				</a>
			</li>
		</ul>
	</div>
																<ul class="list-inline pull-right social-menu">
																	<li>
																		<a target="_blank" href="https://www.linkedin.com/company/xilinx">
																		<span class="linkedin icon"></span>
																		<span class="sr-only">Connect on LinkedIn</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.twitter.com/XilinxInc">
																		<span class="twitter icon"></span>
																		<span class="sr-only">Follow us on Twitter</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.facebook.com/XilinxInc">
																		<span class="facebook icon"></span>
																		<span class="sr-only">Connect on Facebook</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.youtube.com/XilinxInc">
																		<span class="youtube icon"></span>
																		<span class="sr-only">Watch us on YouTube</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.xilinx.com/registration/subscriber-signup.html">
																		<span class="newsletter icon"></span>
																		<span class="sr-only">Subscribe to Newsletter</span>
																		</a>
																	</li>
																</ul>
																	<div class="lang-select dropup hidden-xs hidden-sm">
	<button data-toggle="dropdown">
		<span class="fas fa-globe" aria-hidden="true"></span>
		<span>
			
				English
			</span>
		<span class="far fa-angle-down" aria-hidden="true"></span>
	</button>
	<ul class="dropdown-menu">
		<li>
				<a target="_blank" href="https://japan.xilinx.com/" target="_self">
					日本語
				</a>
			</li>
		<li>
				<a target="_blank" href="https://china.xilinx.com/" target="_self">
					简体中文
				</a>
			</li>
		</ul>
	</div>
															</div>
														</div>
														<div class="col-md-pull-5 col-lg-pull-5 col-md-5 col-lg-5">
															<span class="copyright">©2022 Advanced Micro Devices, Inc</span>
														</div>

													</div>
													                    <div class="movethisrowtoleft row">
                        <div class="col-xs-24">
                            <ul class="sub-menu">
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a></li>
                                <li><a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a></li>
                                <li><a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a></li>
								<li><a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a></li>
                                <li><a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></li>
                            </ul>
                        </div>
                    </div>
												</div>
											</div>
										</div>
									</footer>
								</noindex>
							</div>
						</div>
					</div>
				</div>
<div class="backToTop parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16"><noindex>
    <span data-component="backToTopButton" class="backToTopButton loaded">
        <ul>
            <li>
                <a href="https://www.author.xilinx.com/xx/rebrand/amd/en-amd-xilinx-header-footer.html#top" class="btn top">
                    <span class="fas fa-angle-up" aria-hidden="true"></span>
                </a>
            </li>
        </ul>
    </span>
</noindex></div>
			</div>
		</div>


		<script>window.CQ = window.CQ || {}</script>
		<script src="https://static.cloud.coveo.com/searchui/v2.4382/js/CoveoJsSearch.Lazy.min.js"></script>
		<script>
			var underscoreSetup = function () {
			  _.templateSettings.interpolate = /\{\{=([^-][\S\s]+?)\}\}/g;
			  _.templateSettings.evaluate = /\{\{([^-=][\S\s]+?)\}\}/g;
			  _.templateSettings.escape = /\{\{-([^=][\S\s]+?)\}\}/g;
			}

			underscoreSetup();
		</script>
	</body>
</html>